//3
echo "Enter the limit:"
read n

echo "Series:"
i=1
while [ $i -le $n ]
do
  result=$((i * 5))
  echo "$result"
  i=$((i + 1))
done

//4

#!/bin/bash

if [ $# -ge 2 ]
then
    src=$1
    dest=$2
else
    echo -n "Enter source file: "
    read src
    echo -n "Enter destination file: "
    read dest
fi

if [ ! -f "$src" ]
then
    echo "Source file not found"
    exit 1
fi

cp "$src" "$dest"
echo "File copied."

echo "Contents of destination file:"
cat "$dest"

lines=$(wc -l < "$dest")
words=$(wc -w < "$dest")
chars=$(wc -c < "$dest")
newlines=$lines

echo "File name: $dest" > Third_File.txt
echo "Lines: $lines" >> Third_File.txt
echo "Newlines: $newlines" >> Third_File.txt
echo "Words: $words" >> Third_File.txt
echo "Characters: $chars" >> Third_File.txt

//5

#!/bin/bash

# Create employee data file
cat > employee_data.txt <<EOF
001 Kanti Clerk Product 250000 20
002 Sameer_Kumar_Rai Manager HR 50000 25
003 Anurag_Saxena Technician Server 45000 21
004 Tushar_Chuggani Manager Sales 30000 25
005 Vedant_Saksena Programmer App_Building 150000 24
EOF

# 1. Sort based on Designation
sort -k3 employee_data.txt > sorted_by_designation.txt

# 2(i). Report: Emp ID, Designation, Age
awk '{print $1, $3, $6}' employee_data.txt > report1.txt

# 2(ii). Report: Emp ID, Salary, Age
awk '{print $1, $5, $6}' employee_data.txt > report2.txt

# 3. Count total number of Managers
grep -c "Manager" employee_data.txt > total_managers.txt

# 4. Display all fields except the first
awk '{$1=""; print $0}' employee_data.txt > without_first_field.txt

# 5. Sort by Age and then by Name
sort -k6,6n -k2 employee_data.txt > sorted_by_age_name.txt

# 6. Count employees in each Designation category
awk '{count[$3]++} END {for (i in count) print i, count[i]}' employee_data.txt > designation_count.txt

# 7. Check if given files are sorted, reverse sort if not, and merge
file1="fileA.txt"
file2="fileB.txt"

# sample files
echo -e "3\n1\n2" > $file1
echo -e "6\n5\n4" > $file2

# check sort and reverse sort if needed
sort -c $file1 2>/dev/null
if [ $? -ne 0 ]; then
    sort -nr $file1 -o $file1
fi

sort -c $file2 2>/dev/null
if [ $? -ne 0 ]; then
    sort -nr $file2 -o $file2
fi

# merge both files
cat $file1 $file2 > merged.txt

//6

#!/bin/bash

# Create employees.txt file
cat > employees.txt <<EOF
001 | Kanti | Clerk | Product | 250000 | 20
002 | Sameer Kumar Rai | Manager | HR | 50000 | 25
003 | Anurag Saxena | Technician | Server | 45000 | 21
004 | Tushar Chuggani | Manager | Sales | 30000 | 25
005 | Vedant Saksena | Programmer | App Building | 150000 | 24
EOF

# 1. Remove all blank lines
sed -i '/^$/d' employees.txt

# 2. Search for names containing saxena or saksena
grep -iE "saxena|saksena" employees.txt > found_names.txt

# 3. Identify lines longer than 15 characters
awk 'length($0) > 15' employees.txt > long_lines.txt

# 4. List all ordinary files not writable
find . -type f ! -writable > non_writable_files.txt

# 5. Youngest person who is not a Manager
awk -F'|' '$3 !~ /Manager/ {print $2, $3, $6}' employees.txt | sort -k3n | head -1 > youngest_non_manager.txt

# 6. Process emp.dat file
cat > emp.dat <<EOF
001 Kanti HR 25 M Clerk 20000
002 Sameer HR 35 M Manager 30000
003 Rakesh Sales 45 M Director 80000
004 Neha Product 28 F Clerk 25000
005 Tushar IT 40 M Manager 40000
EOF

# Create department files and calculate Net Salary
while read id name dept age gender desig basic
do
    case $desig in
        Clerk)
            hra=1000
            tax=$(echo "0.05 * $basic" | bc)
            net=$(echo "$basic + $hra - $tax" | bc)
            ;;
        Manager)
            hra=2000
            tax=$(echo "0.10 * $basic" | bc)
            net=$(echo "$basic + $hra - $tax" | bc)
            ;;
        Director)
            hra=5000
            sp_inc=20000
            tax=$(echo "0.20 * $basic" | bc)
            net=$(echo "$basic + $hra + $sp_inc - $tax" | bc)
            ;;
    esac

    echo "$id $name $dept $age $gender $desig $basic $net" >> "${dept}.txt"
done < emp.dat

# Count total Clerks, Managers, Directors
awk '{count[$6]++} END {for (i in count) print i, count[i]}' emp.dat > designation_summary.txt

//7_1

#include <stdio.h>
#include <unistd.h>
#include <string.h>

int main() {
    int fd[2];
    char msg[] = "Hello from parent";
    char buffer[50];

    pipe(fd);
    pid_t pid = fork();

    if (pid == 0) {
        close(fd[1]);
        read(fd[0], buffer, sizeof(buffer));
        printf("Child received: %s\n", buffer);
    } else {
        close(fd[0]);
        write(fd[1], msg, strlen(msg)+1);
    }
    return 0;
}

//7_2
#include <stdio.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>

int main() {
    char *fifo = "myfifo";
    mkfifo(fifo, 0666);

    pid_t pid = fork();

    if (pid == 0) {
        char buffer[50];
        int fd = open(fifo, O_RDONLY);
        read(fd, buffer, sizeof(buffer));
        printf("Child got: %s\n", buffer);
        close(fd);
    } else {
        int fd = open(fifo, O_WRONLY);
        char msg[] = "Hello via FIFO";
        write(fd, msg, strlen(msg)+1);
        close(fd);
    }
    unlink(fifo);
    return 0;
}

//8
#include <stdio.h>

struct process {
    int pid, at, bt, wt, tat, done;
};

int main() {
    int n, i, j, time = 0, completed = 0, min_bt, index;
    printf("Enter number of processes: ");
    scanf("%d", &n);
    struct process p[n];

    for (i = 0; i < n; i++) {
        printf("PID Arrival Burst: ");
        scanf("%d %d %d", &p[i].pid, &p[i].at, &p[i].bt);
        p[i].done = 0;
    }

    printf("\nFCFS Scheduling:\n");
    time = 0;
    for (i = 0; i < n; i++) {
        if (time < p[i].at) time = p[i].at;
        p[i].wt = time - p[i].at;
        p[i].tat = p[i].wt + p[i].bt;
        time += p[i].bt;
        printf("P%d WT=%d TAT=%d\n", p[i].pid, p[i].wt, p[i].tat);
    }

    printf("\nSPN Scheduling:\n");
    time = 0; completed = 0;
    while (completed < n) {
        min_bt = 9999; index = -1;
        for (i = 0; i < n; i++) {
            if (p[i].at <= time && p[i].done == 0 && p[i].bt < min_bt) {
                min_bt = p[i].bt;
                index = i;
            }
        }
        if (index == -1) { time++; continue; }
        p[index].wt = time - p[index].at;
        time += p[index].bt;
        p[index].tat = p[index].wt + p[index].bt;
        p[index].done = 1;
        completed++;
        printf("P%d WT=%d TAT=%d\n", p[index].pid, p[index].wt, p[index].tat);
    }

    return 0;
}
//9
#include <stdio.h>

int main() {
    int n, m;
    printf("Enter number of processes and resources: ");
    scanf("%d %d", &n, &m);

    int alloc[n][m], max[n][m], avail[m], need[n][m], finish[n];
    printf("Enter allocation matrix:\n");
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            scanf("%d", &alloc[i][j]);

    printf("Enter max matrix:\n");
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            scanf("%d", &max[i][j]);

    printf("Enter available resources:\n");
    for (int j = 0; j < m; j++) scanf("%d", &avail[j]);

    for (int i = 0; i < n; i++) {
        finish[i] = 0;
        for (int j = 0; j < m; j++)
            need[i][j] = max[i][j] - alloc[i][j];
    }

    int count = 0, safe[n];
    while (count < n) {
        int found = 0;
        for (int i = 0; i < n; i++) {
            if (finish[i] == 0) {
                int j;
                for (j = 0; j < m; j++)
                    if (need[i][j] > avail[j]) break;
                if (j == m) {
                    for (int k = 0; k < m; k++)
                        avail[k] += alloc[i][k];
                    safe[count++] = i;
                    finish[i] = 1;
                    found = 1;
                }
            }
        }
        if (!found) break;
    }

    if (count == n) {
        printf("System is in safe state.\nSafe sequence: ");
        for (int i = 0; i < n; i++)
            printf("P%d ", safe[i]);
    } else {
        printf("System is not in safe state.\n");
    }

    return 0;
}


//10

#include <stdio.h>

int main() {
    int nb, np;
    printf("Enter number of blocks: ");
    scanf("%d", &nb);
    int block[nb];
    for (int i = 0; i < nb; i++) scanf("%d", &block[i]);

    printf("Enter number of processes: ");
    scanf("%d", &np);
    int process[np];
    for (int i = 0; i < np; i++) scanf("%d", &process[i]);

    int alloc[np];
    for (int i = 0; i < np; i++) alloc[i] = -1;

    for (int i = 0; i < np; i++) {
        for (int j = 0; j < nb; j++) {
            if (block[j] >= process[i]) {
                alloc[i] = j;
                block[j] -= process[i];
                break;
            }
        }
    }

    printf("\nProcess No.\tProcess Size\tBlock No.\n");
    for (int i = 0; i < np; i++) {
        if (alloc[i] != -1)
            printf("%d\t\t%d\t\t%d\n", i + 1, process[i], alloc[i] + 1);
        else
            printf("%d\t\t%d\t\tNot Allocated\n", i + 1, process[i]);
    }

    return 0;
}
